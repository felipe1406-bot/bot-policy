<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pol√≠tica de Privacidade - Bot Discord</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 0 20px;
      line-height: 1.6;
      background-color: #f9f9f9;
      color: #222;
    }
    h1, h2 {
      color: #2c3e50;
    }
    hr {
      margin: 20px 0;
      border: none;
      border-top: 1px solid #ddd;
    }
    footer {
      margin-top: 40px;
      font-size: 0.9em;
      color: #555;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Pol√≠tica de Privacidade</h1>
  <p><strong>√öltima atualiza√ß√£o:</strong> 16 de maio de 2025</p>
  <p>Este bot Discord √© um <strong>simulador de jogos</strong> voltado apenas para entretenimento.</p>
  <p>Ele <strong>n√£o coleta, armazena ou compartilha qualquer dado pessoal</strong> dos usu√°rios.</p>

  <ul>
    <li><strong>Dados coletados:</strong> Nenhum.</li>
    <li><strong>Armazenamento:</strong> Nenhum dado √© salvo fora do Discord.</li>
    <li><strong>Compartilhamento:</strong> Nenhum dado √© compartilhado com terceiros.</li>
    <li><strong>Contato:</strong> N√£o h√° canal oficial de suporte no momento.</li>
  </ul>

  <hr />

  <h1>Termos de Uso</h1>
  <p><strong>√öltima atualiza√ß√£o:</strong> 16 de maio de 2025</p>
  <p>Ao utilizar este bot, voc√™ concorda com os seguintes termos:</p>

  <ul>
    <li>O bot √© fornecido <strong>como est√°</strong>, sem garantias de funcionamento cont√≠nuo ou de resultados.</li>
    <li>O bot √© apenas para <strong>entretenimento</strong>, simula jogos virtuais sem recompensas reais.</li>
    <li>O uso indevido do bot, como spam ou viola√ß√µes das regras do Discord, pode levar √† suspens√£o do uso.</li>
    <li>O criador do bot <strong>n√£o se responsabiliza por perdas, mal-entendidos ou problemas causados pelo uso</strong> da ferramenta.</li>
    <li>Nenhum dado pessoal √© coletado.</li>
  </ul>

  <footer>
    &copy; 2025 Felipe1406-bot
  </footer>
</body>
</html>
.min(maxPlayers, 30));
  const participants = new Map([[message.author.id, message.author]]);
  const raceMessage = await message.reply({
    content: `üèÅ **BRIGA DE EMOJIS**\nPre√ßo para participar: ‚ö° ${formatNumber(parsedPrice)} Raios\nPr√™mio: ‚ö° 0 Raios\nClique em ü•ä para participar!\nParticipantes: 1/${maxPlayers}`,
    components: [new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('joinEmojiRace')
        .setLabel('ü•ä Entrar')
        .setStyle(ButtonStyle.Success)
    )]
  });

  const collector = raceMessage.createMessageComponentCollector({ time: 60000 });

  collector.on('collect', async i => {
    if (i.customId === 'joinEmojiRace') {
      if (participants.has(i.user.id)) {
        await i.reply({ content: 'Voc√™ j√° est√° participando!', ephemeral: true });
        return;
      }
      if (!economy[i.user.id] || economy[i.user.id].money < parsedPrice) {
        await i.reply({ content: 'Voc√™ n√£o tem Raios suficientes!', ephemeral: true });
        return;
      }

      participants.set(i.user.id, i.user);
      economy[i.user.id].money -= parsedPrice;
      saveData(economy);

      await i.reply({ content: `${i.user} entrou na briga!` });
      await raceMessage.edit({ content: `üèÅ **BRIGA DE EMOJIS**\nPre√ßo para participar: ‚ö° ${formatNumber(parsedPrice)} Raios\nPr√™mio: ‚ö° 0 Raios\nParticipantes: ${participants.size}/${maxPlayers}` });

      if (participants.size >= maxPlayers) {
        collector.stop();
      }
    }
  });

  collector.on('end', async () => {
    if (participants.size >= 2) {
      const winnerId = Array.from(participants.keys())[Math.floor(Math.random() * participants.size)];
      const winner = participants.get(winnerId);
      economy[winnerId].money += 0; // Set prize if applicable
      saveData(economy);
      
      await raceMessage.edit({ content: `üèÜ **Ganhador:** ${winner.username}\nPr√™mio: ‚ö° ${formatNumber(0)} Raios`, components: [] });
    } else {
      raceMessage.edit({ content: 'Briga cancelada - Participantes insuficientes!', components: [] });
    }
  });
}) {
  if (typeof text !== 'string') return text;
  text = text.toLowerCase().trim();

  if (text === 'all') {
    return economy[userId]?.money || 0;
  }
  if (text === 'half') {
    return Math.floor((economy[userId]?.money || 0) / 2);
  }

  const multipliers = { 'k': 1000, 'm': 1000000, 'b': 1000000000 };
  try {
    for (const [suffix, multiplier] of Object.entries(multipliers)) {
      if (text.endsWith(suffix)) {
        return parseInt(parseFloat(text.slice(0, -1)) * multiplier);
      }
    }
    return parseInt(text);
  } catch {
    return null;
  }
}

// Bot Setup
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMembers
  ]
});

// Command Handler
client.on('messageCreate', async message => {
  if (!message.content.startsWith(PREFIX) || message.author.bot) return;

  const args = message.content.slice(PREFIX.length).trim().split(/ +/);
  const command = args.shift().toLowerCase();

  switch (command) {
    case 'ping':
      await message.reply('Pong!');
      break;

    case 'bal':
      await handleBalance(message, args);
      break;

    case 'pay':
      await handlePay(message, args);
      break;

    case 'daily':
      await handleDaily(message);
      break;

    case 'crime':
      await handleCrime(message);
      break;

    case 'bet':
      if (args.length >= 2) {
        const user = message.mentions.users.first();
        await handleBet(message, user, args[1]);
      }
      break;

    case 'race':
      if (args.length >= 1) {
        await handleRace(message, args[0], args[1] || 2);
      }
      break;

    case 'top':
      await handleTop(message);
      break;

    case 'rifa':
      if (args.length >= 1) {
        if (args[0].toLowerCase() === 'buy') {
          await handleRifa(message, args[1], 'buy', args[2]);
        } else if (['r', 'n', 'd'].includes(args[0].toLowerCase())) {
          await handleRifa(message, args[0]);
        } else {
          const embed = new EmbedBuilder()
            .setDescription('Use:\nZrifa (r/n/d) - Ver status da rifa\nZrifa buy (r/n/d) [quantidade] - Comprar tickets')
            .setColor('Red');
          await message.reply({ embeds: [embed] });
        }
      } else {
        const embed = new EmbedBuilder()
          .setDescription('Use:\nZrifa (r/n/d) - Ver status da rifa\nZrifa buy (r/n/d) [quantidade] - Comprar tickets')
          .setColor('Red');
        await message.reply({ embeds: [embed] });
      }
      break;
        case 'addmagias':
            if(message.author.id === OWNER_ID){
                const user = message.mentions.users.first();
                const amount = parseNumber(args[1], message.author.id);
                if(user && amount > 0){
                    if(!economy[user.id]) economy[user.id] = {money:0};
                    economy[user.id].money += amount;
                    saveData(economy);
                    message.reply(`Adicionado ${formatNumber(amount)} Magias para ${user.username}!`);
                } else {
                    message.reply("Formato incorreto. Use: Zaddmagias @user <amount>");
                }
            }
            break;
        case 'removemagias':
            if(message.author.id === OWNER_ID){
                const user = message.mentions.users.first();
                const amount = parseInt(args[1]);
                if(user && amount > 0){
                    if(!economy[user.id]) economy[user.id] = {money:0};
                    economy[user.id].money = Math.max(0, economy[user.id].money - amount);
                    saveData(economy);
                    message.reply(`Removido ${formatNumber(amount)} Magias de ${user.username}!`);
                } else {
                    message.reply("Formato incorreto. Use: Zremovemagias @user <amount>");
                }
            }
            break;
  }
});

// Command Functions
async function handleBalance(message, args) {
  const user = message.mentions.users.first() || message.author;
  const userId = user.id;

  if (!economy[userId]) {
    economy[userId] = {
      money: 0,
      lastDaily: 0,
      lastCrime: 0,
      lastWork: 0
    };
    saveData(economy);
  }

  const balance = economy[userId].money;
  const userEntries = Object.entries(economy)
    .filter(([_, v]) => typeof v === 'object' && 'money' in v)
    .sort(([_, a], [__, b]) => b.money - a.money);

  const rank = userEntries.findIndex(([id]) => id === userId) + 1;

  await message.reply(`üí∞ @${user.username}, Voc√™ possui **${formatNumber(balance)}** Raios! Voc√™ est√° em **#${rank}** lugar no ranking! Veja outros ostentadores em **Ztop**`);
}

async function handleDaily(message) {
  const userId = message.author.id;

  if (!economy[userId]) {
    economy[userId] = {
      money: 0,
      lastDaily: 0,
      lastCrime: 0,
      lastWork: 0
    };
  }

  const now = Date.now();
  const lastDaily = economy[userId].lastDaily;
  if (now - lastDaily < 86400000) {
    await message.reply('**Voc√™ j√° pegou sua recompensa di√°ria hoje! Volte amanh√£.**');
    return;
  }

  const reward = Math.floor(Math.random() * 40001) + 10000;
  economy[userId].money += reward;
  economy[userId].lastDaily = now;
  saveData(economy);

  await message.reply(`**Voc√™ recebeu sua recompensa di√°ria de ${formatNumber(reward)} Raios!**`);
}

async function handleCrime(message) {
  const userId = message.author.id;

  if (!economy[userId]) {
    economy[userId] = {
      money: 0,
      lastDaily: 0,
      lastCrime: 0,
      lastWork: 0
    };
  }

  const now = Date.now();
  const lastCrime = economy[userId].lastCrime;
  if (now - lastCrime < 3600000) {
    await message.reply('**Voc√™ s√≥ pode fazer crimes uma vez a cada hora!**');
    return;
  }

  const result = Math.random() < 0.5;
  const amount = Math.floor(Math.random() * 4001) + 1000;

  economy[userId].lastCrime = now;
  if (result) {
    economy[userId].money += amount;
    await message.reply(`**Voc√™ cometeu um crime e ganhou ${formatNumber(amount)} Raios!**`);
  } else {
    economy[userId].money -= amount;
    await message.reply(`**Voc√™ cometeu um crime e perdeu ${formatNumber(amount)} Raios!**`);
  }

  saveData(economy);
}

async function handleTop(message) {
  const userData = Object.entries(economy)
    .filter(([_, v]) => typeof v === 'object' && 'money' in v)
    .sort(([_, a], [__, b]) => b.money - a.money)
    .slice(0, 10);

  const embed = new EmbedBuilder()
    .setTitle('üèÜ **Ranking dos mais ricos**')
    .setColor(0xFFD700);

  for (const [i, [userId, data]] of userData.entries()) {
    const user = await client.users.fetch(userId);
    embed.addFields({
      name: `#${i + 1} **${user.username}**`,
      value: `üí∞ **${formatNumber(data.money)} Raios**`,
      inline: false
    });
  }

  embed.setFooter({ text: 'Use Zbal para ver seu saldo' });
  await message.reply({ embeds: [embed] });
}

async function handlePay(message, args) {
    const user = message.mentions.users.first();
    const amount = parseNumber(args[1], message.author.id);
    if(user && amount > 0){
        const senderId = message.author.id;
        const receiverId = user.id;
        if(economy[senderId] && economy[senderId].money >= amount){
            const embed = new EmbedBuilder()
                .setDescription(`Apolo_money ${user.username}, ${message.author.username} deseja lhe enviar ${formatNumber(amount)} Magias!\nConfirme a transa√ß√£o clicando em Aceitar.`)
                .setColor("Green");

            const button = new ButtonBuilder()
                .setCustomId('payConfirm')
                .setLabel('Aceitar')
                .setStyle(ButtonStyle.Success);

            const row = new ActionRowBuilder().addComponents(button);
            const msg = await message.reply({embeds:[embed], components:[row]});

            const collector = msg.createMessageComponentCollector({time: 600000});
            collector.on('collect', async i => {
                if(i.user.id === user.id && i.customId === 'payConfirm'){
                    economy[senderId].money -= amount;
                    if(!economy[receiverId]) economy[receiverId] = {money:0};
                    economy[receiverId].money += amount;
                    saveData(economy);
                    i.reply(`Pagamento confirmado! ${message.author.username} enviou ${formatNumber(amount)} Magias para ${user.username}.`);
                    msg.edit({embeds:[], components:[]});
                } else {
                    i.reply({content:"Voc√™ n√£o pode interagir com esse bot√£o!", ephemeral:true});
                }
            });
            collector.on('end', () => {
                msg.edit({components:[]});
            });

        } else {
            message.reply("Saldo insuficiente!");
        }
    } else {
        message.reply("Formato incorreto. Use: Zpay @user <amount>");
    }
}

async function handleBet(message, user, amount) {
  const parsedAmount = parseNumber(amount, message.author.id);

  if (!parsedAmount || parsedAmount <= 0) {
    await message.reply('**Por favor, insira um valor v√°lido (ex: 100, 1k, 1m)**');
    return;
  }

  const authorId = message.author.id;
  const userId = user.id;

  if (!economy[authorId] || economy[authorId].money < parsedAmount) {
    await message.reply('**Voc√™ n√£o tem Magias suficientes!**');
    return;
  }

  if (!economy[userId] || economy[userId].money < parsedAmount) {
    await message.reply(`**${user.username} n√£o tem Magias suficientes!**`);
    return;
  }

  const tax = (isVip(message.author) || isVip(user)) ? 0 : Math.floor(parsedAmount * 0.05);
  const taxMessage = (isVip(message.author) || isVip(user)) ?
    'Como pelo menos um jogador possui VIP, essa aposta n√£o ter√° taxa!' :
    `Nenhum dos jogadores possui VIP. Taxa de 5% (${formatNumber(tax)} Magias) ser√° aplicada!`;

  const acceptedUsers = new Set([message.author.id]); // Creator counts as accepted
  const participants = new Map([[message.author.id, message.author], [userId, user]]);

  const updateMessage = () => {
    const acceptedList = Array.from(acceptedUsers).map(id => participants.get(id).username).join(', ');
    return `**${message.author.username} quer fazer uma aposta com voc√™ valendo ${formatNumber(parsedAmount)} Magias!**\n` +
           `Participantes aceitos (${acceptedUsers.size}/2): **${acceptedList}**\n\n` +
           `Se ${message.author.username} vencer, ${message.author} ganha ${formatNumber(parsedAmount)} Magias\n` +
           `Se ${user.username} vencer, ${user} ganha ${formatNumber(parsedAmount)} Magias\n\n${taxMessage}`;
  };

  const button = new ButtonBuilder()
    .setCustomId('betConfirm')
    .setLabel(`Aceitar (${acceptedUsers.size}/2)`)
    .setStyle(ButtonStyle.Success);
  const row = new ActionRowBuilder().addComponents(button);

  const betMessage = await message.reply({ content: updateMessage(), components: [row]});
  const collector = betMessage.createMessageComponentCollector({ time: 30000 });

  collector.on('collect', async i => {
    if (participants.has(i.user.id)) {
      if (i.customId === 'betConfirm') {
        if (acceptedUsers.has(i.user.id)) {
          acceptedUsers.delete(i.user.id);
          await i.reply({ content: 'Confirma√ß√£o retirada!', ephemeral: true });
        } else {
          acceptedUsers.add(i.user.id);
          await i.reply({ content: 'Aposta aceita!', ephemeral: true });
        }
        button.setLabel(`Aceitar (${acceptedUsers.size}/2)`);
        const newRow = new ActionRowBuilder().addComponents(button);
        await betMessage.edit({ content: updateMessage(), components: [newRow] });

        if (acceptedUsers.size === 2) {
          const winner = Math.random() < 0.5 ? message.author : user;
          const loser = winner === message.author ? user : message.author;
          const finalAmount = parsedAmount - tax;
          economy[winner.id].money += finalAmount;
          economy[loser.id].money -= parsedAmount;
          saveData(economy);
          const resultEmbed = new EmbedBuilder()
            .setTitle('Resultado da Aposta')
            .setDescription(`**Vencedor:** ${winner}\n**Pr√™mio:** ${formatNumber(finalAmount)} Magias${tax > 0 ? `\n**Taxa:** ${formatNumber(tax)} Magias` : ''}`)
            .setColor('Green');
          await betMessage.edit({ content: '', embeds: [resultEmbed], components: [] });
          collector.stop();
        }
      }
    } else {
      await i.reply({ content: 'Voc√™ n√£o pode interagir com este bot√£o!', ephemeral: true });
    }
  });

  collector.on('end', () => {
    if (acceptedUsers.size < 2) {
      betMessage.edit({ content: 'Aposta cancelada - Tempo esgotado!', components: [] });
    }
  });
}


async function handleRace(message, price, maxPlayers) {
  const parsedPrice = parseNumber(price, message.author.id);
  if (!parsedPrice || parsedPrice <= 0) {
    await message.reply('**Por favor, insira um valor v√°lido (ex: 100, 1k, 1m)**');
    return;
  }

  maxPlayers = Math.max(2, Math.min(maxPlayers, 10));
  const participants = new Map([[message.author.id, message.author]]); // Include creator

  const updateEmbed = () => {
    const participantsList = Array.from(participants.values()).map(user => user.username).join('\n');
    const embed = new EmbedBuilder()
      .setTitle('üèÅ Corrida de Magias')
      .setColor('Orange')
      .addFields(
        { name: 'Info', value: `Pre√ßo para participar: üí∞ **${formatNumber(parsedPrice)} Magias**\nPr√™mio atual: üèÜ **${formatNumber(participants.size * parsedPrice)} Magias**`, inline: false },
        { name: 'Participantes', value: participantsList || 'Aguardando participantes...', inline: false },
        { name: 'Corrida', value: 'Para participar clique em **Participar**\nEssa corrida ter√° apenas um ganhador\n', inline: false }
      )
      .setFooter({ text: `Participantes: ${participants.size}/${maxPlayers}` });
    return embed;
  };

  const joinButton = new ButtonBuilder()
    .setCustomId('joinRace')
    .setLabel('Participar')
    .setStyle(ButtonStyle.Success);
  const row = new ActionRowBuilder().addComponents(joinButton);

  const raceMessage = await message.reply({ embeds: [updateEmbed()], components: [row] });
  const collector = raceMessage.createMessageComponentCollector({ time: 60000 });

  const startRace = async () => {
    const participantIds = Array.from(participants.keys());
    const winnerId = participantIds[Math.floor(Math.random() * participantIds.length)];
    const winner = participants.get(winnerId);
    const prize = participants.size * parsedPrice;
    
    if (!economy[winnerId]) economy[winnerId] = { money: 0 };
    economy[winnerId].money += prize;
    saveData(economy);
    
    const resultEmbed = new EmbedBuilder()
      .setTitle('Resultado da Corrida')
      .setDescription(`${winner} venceu a corrida e ganhou ${formatNumber(prize)} Magias!`)
      .setColor('Green');
    await raceMessage.edit({ embeds: [resultEmbed], components: [] });
    collector.stop();
  };

  collector.on('collect', async i => {
    if (i.customId === 'joinRace') {
      if (participants.has(i.user.id)) {
        await i.reply({ content: 'Voc√™ j√° est√° participando!', ephemeral: true });
        return;
      }
      if (!economy[i.user.id] || economy[i.user.id].money < parsedPrice) {
        await i.reply({ content: 'Voc√™ n√£o tem Magias suficientes!', ephemeral: true });
        return;
      }

      participants.set(i.user.id, i.user);
      economy[i.user.id].money -= parsedPrice;
      saveData(economy);
      
      await i.reply({ content: `${i.user} entrou na corrida!` });
      await raceMessage.edit({ embeds: [updateEmbed()] });

      if (participants.size >= maxPlayers) {
        await startRace();
      }
    }
  });

  collector.on('end', () => {
    if (participants.size >= 2) {
      startRace();
    } else {
      raceMessage.edit({ content: 'Corrida cancelada - Participantes insuficientes!', components: [] });
    }
  });
}


async function handleRifa(message, type, command, quantity) {
  const typeMap = {
    "r": "relampago",
    "n": "normal",
    "d": "diaria"
  };

  const rifaDurations = {
    "r": 10 * 60 * 1000,    // 10 minutos
    "n": 25 * 60 * 1000,    // 25 minutos
    "d": 24 * 60 * 60 * 1000 // 24 horas
  };

  const rifaNames = {
    "r": "Rel√¢mpago",
    "n": "Normal",
    "d": "Di√°ria"
  };

  if (!type) {
    await message.channel.send("Comandos:\nZrifa (r/n/d) - Ver status da rifa\nZrifa buy (r/n/d) [quantidade] - Comprar tickets\n\nTipos:\nr - Rel√¢mpago (10 min)\nn - Normal (25 min)\nd - Di√°ria (24h)");
    return;
  }

  let realType = typeMap[type.toLowerCase()] || type;

  if (!rifaDurations[type.toLowerCase()]) {
    await message.channel.send("Tipo de rifa inv√°lido! Use:\nr - Rel√¢mpago (10 min)\nn - Normal (25 min)\nd - Di√°ria (24h)");
    return;
  }

  if (!economy[realType]) {
    economy[realType] = { tickets: [], last_winner: null, last_prize: 0, last_sorteio: Date.now() };
  }

  const userId = message.author.id;
  if (!economy[userId]) economy[userId] = { money: 0 };

  if (command && command.toLowerCase() === "buy") {
    const parsedQuantity = parseNumber(quantity, userId);
    if (!parsedQuantity || parsedQuantity <= 0) {
      await message.channel.send("Por favor, insira uma quantidade v√°lida!");
      return;
    }

    const totalCost = 500 * parsedQuantity;
    if (economy[userId].money < totalCost) {
      await message.channel.send("Voc√™ n√£o tem Magias suficientes!");
      return;
    }

    economy[userId].money -= totalCost;
    economy[realType].tickets.push(...Array(parsedQuantity).fill(userId));
    if (!economy[realType].last_sorteio) {
      economy[realType].last_sorteio = Date.now();
    }
    saveData(economy);

    const totalTickets = economy[realType].tickets.length;
    const userTickets = economy[realType].tickets.filter(id => id === userId).length;
    const chance = (userTickets / totalTickets * 100);

    const buyButton = new ButtonBuilder()
      .setCustomId('buyTickets_' + realType)
      .setLabel('Comprar Tickets')
      .setStyle(ButtonStyle.Success);

    const participantsButton = new ButtonBuilder()
      .setCustomId('showParticipants_' + realType)
      .setLabel('Ver Participantes')
      .setStyle(ButtonStyle.Primary);

    const row = new ActionRowBuilder().addComponents(buyButton, participantsButton);

    const ticketEndTime = new Date(economy[realType].last_sorteio + rifaDurations[type.toLowerCase()]);
    await message.channel.send({
      content: `üé´ @${message.author.username} comprou ${parsedQuantity} tickets da rifa ${rifaNames[type.toLowerCase()]}!\n` +
        `‚è≥ Resultado sair√° em: **${ticketEndTime.toLocaleString('pt-BR')}**\n` +
        `üìä Sua chance de ganhar: **${chance.toFixed(2)}%**`,
      components: [row]
    });
  } else {
    const totalTickets = economy[realType].tickets.length;
    const uniqueParticipants = new Set(economy[realType].tickets).size;
    const endTime = new Date(economy[realType].last_sorteio + rifaDurations[type.toLowerCase()]);
    const chance = (1 / (totalTickets + 1) * 100);

    const buyButton = new ButtonBuilder()
      .setCustomId('buyTickets_' + realType)
      .setLabel('Comprar Tickets')
      .setStyle(ButtonStyle.Success);

    const participantsButton = new ButtonBuilder()
      .setCustomId('showParticipants_' + realType)
      .setLabel('Ver Participantes')
      .setStyle(ButtonStyle.Primary);

    const row = new ActionRowBuilder().addComponents(buyButton, participantsButton);

    const userTickets = economy[realType].tickets.filter(id => id === userId).length;
    const totalPrize = totalTickets * 500;
    let probability;

    if (uniqueParticipants <= 1) {
      probability = 100;
    } else {
      probability = (userTickets / totalTickets) * 100;
    }

    const timeLeft = new Date(economy[realType].last_sorteio + rifaDurations[type.toLowerCase()]);

    await message.channel.send({
      content: `üéÅ @${message.author.username} RIFA ${rifaNames[type.toLowerCase()]}\n` +
        `üí∞ Pr√™mio atual: **${formatNumber(totalPrize)} Raios**\n` +
        `üé´ Tickets comprados: **${formatNumber(totalTickets)} Tickets**\n` +
        `üë• Pessoas participando: **${formatNumber(uniqueParticipants)} Pessoas**\n` +
        `üòé √öltimo ganhador: ${economy[realType].last_winner || 'Ningu√©m'} (${formatNumber(economy[realType].last_prize)} Raios)\n` +
        `‚è≤Ô∏è Resultado ir√° sair em: **${timeLeft.toLocaleString('pt-BR')}**\n` +
        `üíµ Compre um ticket por 500 Raios usando !rifa ${realType} comprar\n` +
        `üéâ Cada pessoa pode comprar no m√°ximo 500,000 tickets na Rifa ${rifaNames[type.toLowerCase()]}`,
      components: [row]
    });
  }
}

// Add button interaction handler
client.on('interactionCreate', async interaction => {
  if (!interaction.isButton()) return;

  const [action, type] = interaction.customId.split('_');

  if (action === 'buyTickets') {
    const buy1 = new ButtonBuilder()
      .setCustomId(`confirmBuy_${type}_1`)
      .setLabel('1 Ticket')
      .setStyle(ButtonStyle.Success);

    const buy100 = new ButtonBuilder()
      .setCustomId(`confirmBuy_${type}_100`)
      .setLabel('100 Tickets')
      .setStyle(ButtonStyle.Success);

    const buy1000 = new ButtonBuilder()
      .setCustomId(`confirmBuy_${type}_1000`)
      .setLabel('1000 Tickets')
      .setStyle(ButtonStyle.Success);

    const row = new ActionRowBuilder().addComponents(buy1, buy100, buy1000);

    await interaction.reply({
      content: `üéüÔ∏è @${interaction.user.username} Escolha quantos tickets deseja comprar:`,
      components: [row],
      ephemeral: true
    });
  } else if (action === 'showParticipants') {
    const participants = {};
    economy[type].tickets.forEach(userId => {
      participants[userId] = (participants[userId] || 0) + 1;
    });

    const participantsList = await Promise.all(
      Object.entries(participants)
        .sort(([,a], [,b]) => b - a)
        .map(async ([userId, count]) => {
          const user = await client.users.fetch(userId);
          return `${user.username}: ${count} tickets`;
        })
    );

    await interaction.reply({
      content: `**Participantes da Rifa ${type}:**\n${participantsList.join('\n')}`,
      ephemeral: true
    });
  } else if (action === 'confirmBuy') {
    const [, type, amount] = interaction.customId.split('_');
    let parsedAmount;
    const userId = interaction.user.id;
    const TICKET_PRICE = 500;

    if (!economy[userId]) economy[userId] = { money: 0 };

    if (amount.toLowerCase() === 'all') {
      parsedAmount = Math.min(
        Math.floor(economy[userId].money / TICKET_PRICE),
        TICKET_LIMITS[type]
      );
      if (parsedAmount === 0) {
        await interaction.reply({
          content: "Voc√™ n√£o tem Raios suficientes para comprar tickets!",
          ephemeral: true
        });
        return;
      }
    } else if (amount.toLowerCase() === 'half') {
      parsedAmount = Math.floor((economy[userId].money / TICKET_PRICE) / 2);
      if (parsedAmount === 0) {
        await interaction.reply({
          content: "Voc√™ n√£o tem Raios suficientes para comprar tickets!",
          ephemeral: true
        });
        return;
      }
    } else {
      parsedAmount = parseInt(amount);
    }

    // Limitar ao m√°ximo de tickets permitido
    parsedAmount = Math.min(parsedAmount, MAX_TICKETS);
    const totalCost = TICKET_PRICE * parsedAmount;

    if (economy[userId].money < totalCost) {
      parsedAmount = Math.floor(economy[userId].money / TICKET_PRICE);
      if (parsedAmount > 0) {
        await interaction.reply({
          content: `Voc√™ s√≥ tem Raios suficientes para comprar ${parsedAmount} tickets. Comprando o m√°ximo poss√≠vel...`,
          ephemeral: true
        });
      } else {
        await interaction.reply({
          content: "Voc√™ n√£o tem Raios suficientes!",
          ephemeral: true
        });
        return;
      }
    }

    // Limit to max tickets
    parsedAmount = Math.min(parsedAmount, MAX_TICKETS);

    if (economy[userId].money < totalCost) {
      await interaction.reply({
        content: "Voc√™ n√£o tem Magias suficientes!",
        ephemeral: true
      });
      return;
    }

    economy[userId].money -= totalCost;
    economy[type].tickets.push(...Array(parsedAmount).fill(userId));
    saveData(economy);

    const totalTickets = economy[type].tickets.length;
    const uniqueParticipants = new Set(economy[type].tickets).size;
    const userTickets = economy[type].tickets.filter(id => id === userId).length;
    const probability = uniqueParticipants <= 1 ? 100 : (userTickets / totalTickets * 100);
    const endTime = new Date(economy[type].last_sorteio + (rifaDurations[type]));

    await interaction.reply({
      content: `üé´ Voc√™ comprou ${parsedAmount} tickets da rifa ${type}!\n` +
        `‚è≥ Resultado sair√° em: **${endTime.toLocaleString('pt-BR')}**\n` +
        `üìä Sua chance de ganhar: **${probability.toFixed(2)}%**\n` +
        `üí∞ Custo total: **${formatNumber(totalCost)} Raios**`,
      ephemeral: true
    });
  }
});

// Start the bot
client.on('ready', () => {
  console.log(`Bot ${client.user.tag} est√° online!`);
  setInterval(async () => {
    for (const type in TIPOS_RIFA) {
      try {
        await runRifa(type);
      } catch (error) {
        console.error(`Erro na rifa ${type}: ${error}`);
      }
    }
  }, 60000); // Run every minute

});
async function runRifa(tipo) {
  if (!economy[tipo]) {
    economy[tipo] = { tickets: [], last_winner: null, last_prize: 0, last_sorteio: 0 };
    return;
  }

  if (!economy[tipo].tickets || economy[tipo].tickets.length === 0) {
    return;
  }

  const now = Date.now();
  const duration = TIPOS_RIFA[tipo] * 60000;
  if (now - economy[tipo].last_sorteio < duration) {
    return;
  }

  try {
    const winnerId = economy[tipo].tickets[Math.floor(Math.random() * economy[tipo].tickets.length)];
    if (!winnerId) return;

    const winner = await client.users.fetch(winnerId);
    const prize = economy[tipo].tickets.length * 500;

    if (!economy[winnerId]) economy[winnerId] = { money: 0 };
    economy[winnerId].money += prize;
    economy[tipo].last_winner = winner.username;
    economy[tipo].last_prize = prize;
    economy[tipo].tickets = [];
    economy[tipo].last_sorteio = now;
    saveData(economy);

    const channel = await client.channels.fetch('1234567890'); // Replace with your announcement channel ID
    if (channel) {
      const embed = new EmbedBuilder()
        .setTitle(`üéâ RIFA ${tipo.toUpperCase()} FINALIZADA!`)
        .setDescription(`üèÜ **Ganhador:** ${winner}\nüí∞ **Pr√™mio:** ${formatNumber(prize)} Magias`)
        .setColor('Green');

      await channel.send({ embeds: [embed] });
    }
  } catch (error) {
    console.error(`Erro ao processar rifa ${tipo}:`, error);
  }
}

// Removed old handleRifaStatus function as it's no longer needed


    client.login(process.env.DISCORD_TOKEN);